/**
 * Copyright (c) 2026, WSO2 LLC. (https://www.wso2.com).
 *
 * WSO2 LLC. licenses this file to you under the Apache License,
 * Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

import { useCallback, useEffect, useMemo, useState } from "react";
import { Alert, Box, Button, Stack } from "@wso2/oxygen-ui";
import { ArrowLeft, ArrowRight } from "@wso2/oxygen-ui-icons-react";
import { PageLayout } from "@agent-management-platform/views";
import { createMonitorSchema, type CreateMonitorFormValues } from "../form/schema";
import type { EvaluatorResponse } from "@agent-management-platform/types";
import { CreateMonitorForm } from "./CreateMonitorForm";
import { SelectPresetMonitors } from "./SelectPresetMonitors";
import { slugifyMonitorName } from "../utils/monitorFormUtils";
import { useValidatedForm } from "../hooks/useValidatedForm";

interface MonitorFormWizardProps {
    title: string;
    description?: string;
    backHref: string;
    submitLabel: string;
    onSubmit: (values: CreateMonitorFormValues) => void;
    initialValues: CreateMonitorFormValues;
    isSubmitting: boolean;
    serverError?: unknown;
    missingParamsMessage?: string | null;
    backLabel?: string;
    isTypeEditable?: boolean;
}

export function MonitorFormWizard({
    title,
    description,
    backHref,
    submitLabel,
    onSubmit,
    initialValues,
    isSubmitting,
    serverError,
    missingParamsMessage,
    backLabel = "Back to Monitors",
    isTypeEditable = true,
}: MonitorFormWizardProps) {
    const [page, setPage] = useState<1 | 2>(1);
    const [formData, setFormData] = useState<CreateMonitorFormValues>(initialValues);

    useEffect(() => {
        setFormData(initialValues);
        setPage(1);
    }, [initialValues]);

    const { errors, setFieldError, validateField, lastSubmittedValidationErrors, guardSubmit } =
        useValidatedForm<CreateMonitorFormValues>(createMonitorSchema);

    const handleFieldChange = useCallback(
        (field: keyof CreateMonitorFormValues, rawValue: unknown) => {
            setFormData((prev) => {
                let value = rawValue;
                if ((field === "intervalMinutes" || field === "samplingRate") && typeof rawValue === "string") {
                    value = rawValue ? Number(rawValue) : undefined;
                }
                const next = { ...prev, [field]: value } as CreateMonitorFormValues;

                if (field === "displayName") {
                    const autoGenerated = slugifyMonitorName(String(rawValue ?? ""));
                    const previousAuto = slugifyMonitorName(prev.displayName ?? "");
                    if (!prev.name || prev.name === previousAuto) {
                        next.name = autoGenerated;
                    }
                }

                const fieldError = validateField(field, next[field], next);
                setFieldError(field, fieldError);

                if (field === "displayName" || field === "name") {
                    const slugError = validateField("name", next.name, next);
                    setFieldError("name", slugError);
                }

                return next;
            });
        }, [setFieldError, validateField]);

    const handleToggleEvaluator = useCallback((ev: EvaluatorResponse) => {
        setFormData((prev) => {
            const exists = prev.evaluators.some(
                (evaluator) => evaluator.identifier === ev.identifier);
            const nextEvaluators = exists
                ? prev.evaluators.filter((evaluator) => evaluator.identifier !== ev.identifier)
                : [...prev.evaluators, {
                    identifier: ev.identifier,
                    displayName: ev.displayName,
                }];
            // LLM credentials are a flat list; no per-evaluator filtering
            const nextLLMConfigs = prev.llmProviderConfigs ?? [];

            const next = {
                ...prev,
                evaluators: nextEvaluators,
                llmProviderConfigs: nextLLMConfigs,
            } as CreateMonitorFormValues;
            const evalError = validateField("evaluators", nextEvaluators, next);
            setFieldError("evaluators", evalError);
            return next;
        });
    }, [setFieldError, validateField]);

    const handleSaveEvaluatorConfig = useCallback((ev: EvaluatorResponse,
        config: Record<string, unknown>) => {
        setFormData((prev) => {
            const exists = prev.evaluators.some(
                (evaluator) => evaluator.identifier === ev.identifier);
            const nextEvaluators = exists
                ? prev.evaluators.map((evaluator) =>
                    evaluator.identifier === ev.identifier ? { ...evaluator, config } : evaluator)
                : [...prev.evaluators, {
                    identifier: ev.identifier,
                    displayName: ev.displayName,
                    config,
                }];
            const next = { ...prev, evaluators: nextEvaluators } as CreateMonitorFormValues;
            const evalError = validateField("evaluators", nextEvaluators, next);
            setFieldError("evaluators", evalError);
            return next;
        });
    }, [setFieldError, validateField]);

    const handleLLMProviderConfigsChange = useCallback(
        (configs: CreateMonitorFormValues["llmProviderConfigs"]) => {
            setFormData((prev) => ({ ...prev, llmProviderConfigs: configs ?? [] }));
        },
        []
    );

    const handleSubmit = useCallback(() => {
        if (missingParamsMessage) {
            setPage(1);
            return;
        }

        if (!guardSubmit(formData)) {
            setPage(1);
            return;
        }

        onSubmit(formData);
    }, [formData, missingParamsMessage, onSubmit, guardSubmit]);

    const canAdvance = formData.displayName.trim().length >= 3 && formData.name.trim().length >= 3;
    const scheduleReady = formData.type === "future" || (!!formData.traceStart && !!formData.traceEnd);
    const evaluatorsSelected = formData.evaluators.length > 0;
    const isSubmissionReady = canAdvance && scheduleReady &&
        evaluatorsSelected && !missingParamsMessage;

    const serverErrorMessage = useMemo(() => {
        if (!serverError) {
            return null;
        }
        if (serverError instanceof Error) {
            return serverError.message;
        }
        if (typeof serverError === "string") {
            return serverError;
        }
        return "Something went wrong while saving the monitor.";
    }, [serverError]);

    return (
        <PageLayout
            title={title}
            description={description}
            disableIcon
            backLabel={backLabel}
            backHref={backHref}
        >
            <Stack spacing={3}>
                {missingParamsMessage && (
                    <Alert severity="error">
                        {missingParamsMessage}
                    </Alert>
                )}
                {serverErrorMessage && (
                    <Alert severity="error">
                        {serverErrorMessage}
                    </Alert>
                )}
                {
                    page === 1 && (
                        <CreateMonitorForm
                            formData={formData}
                            errors={errors}
                            onFieldChange={handleFieldChange}
                            isTypeEditable={isTypeEditable}
                        />
                    )
                }

                {
                    page === 2 && (
                        <SelectPresetMonitors
                            selectedEvaluators={formData.evaluators}
                            onToggleEvaluator={handleToggleEvaluator}
                            onSaveEvaluatorConfig={handleSaveEvaluatorConfig}
                            llmProviderConfigs={formData.llmProviderConfigs ?? []}
                            onLLMProviderConfigsChange={handleLLMProviderConfigsChange}
                            error={errors.evaluators}
                        />
                    )
                }
                <Stack direction="row" gap={2}>
                    {
                        page === 1 && (
                            <Button
                                variant="contained"
                                color="primary"
                                endIcon={<ArrowRight size={20} />}
                                onClick={() => setPage(2)}
                                disabled={!canAdvance || Boolean(missingParamsMessage)}
                            >
                                Next
                            </Button>
                        )
                    }
                    {
                        page === 2 && (
                            <>
                                <Button
                                    variant="outlined"
                                    startIcon={<ArrowLeft size={20} />}
                                    color="primary"
                                    onClick={() => setPage(1)}
                                >
                                    Previous
                                </Button>
                                {Object.keys(lastSubmittedValidationErrors).length > 0 && (
                                    <Alert severity="error">
                                        {Object.values(lastSubmittedValidationErrors).
                                            map((error, i) => (
                                                <Box key={i}>{error}</Box>
                                            ))}
                                    </Alert>
                                )}
                                <Button
                                    variant="contained"
                                    color="primary"
                                    disabled={!isSubmissionReady || isSubmitting}
                                    onClick={handleSubmit}
                                >
                                    {submitLabel}
                                </Button>
                            </>
                        )
                    }
                </Stack>
            </Stack>
        </PageLayout>
    );
}

export default MonitorFormWizard;
